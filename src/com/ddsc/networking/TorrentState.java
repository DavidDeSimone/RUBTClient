package com.ddsc.networking;

import java.io.File;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.net.InetAddress;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.List;

import com.ddsc.giventools.TorrentInfo;

public class TorrentState implements Serializable {
	
	private static final long serialVersionUID = 1L;
	public static final int DEFAULT_LISTENING_PORT = 6881;

	// Final variables
	protected final String info_hash; // from .torrent file
	protected final byte[] peer_id; // generated by client
	protected final int num_pieces;
	protected final File outfile;
	protected final long startTimeInNanos;

	// Mutable: current state
	private int uploaded;
	private int downloaded;
	private int left;
	private String event;
	protected int listeningPort; // the port on which we are listening for connections
	protected long finishTimeInNanos;


	protected Torrent torrent;
	protected transient TorrentInfo info; // contains data read in from .torrent
	
	public Torrent getTorrent() {
		return torrent;
	}
	
	public TorrentState(TorrentInfo info, File outfile, long startTimeInNanos) {
		this.info = info;
		this.outfile = outfile;
		this.startTimeInNanos = startTimeInNanos;
		
		info_hash = new String(info.info_hash.array(), Charset.forName("ISO-8859-1"));
		peer_id = Torrent.generatePeerId();
		uploaded = 0;
		downloaded = 0;
		left = info.file_length;
		event = "started";
		
		num_pieces = info.piece_hashes.length;
		listeningPort = -1;

		//Spawn and run the torrent for this state
		torrent = new Torrent(this);
	}
	
	/**
	 * Starts a new torrent.
	 */
	public void startTorrent(InetAddress downloadFrom) {
		torrent.setDownloadFrom(downloadFrom);
		new Thread(torrent).run();
	}
	
	/**
	 * Resumes a torrent that was serialized to disk.
	 * @param ti a TorrentInfo instance for the .torrent file
	 */
	public void resumeTorrent(TorrentInfo ti, InetAddress downloadFrom) {
		info = ti;
		torrent.resume();
		torrent.setDownloadFrom(downloadFrom);
		new Thread(torrent).run();
	}
	
	// access to final variable not synchronized
	public TorrentInfo getTorrentInfo() {
		return info;
	}

	// access to final variable not synchronized
	public String getInfoHash() {
		return info_hash;
	}

	// access to final variable not synchronized
	public byte[] getPeerId() {
		return peer_id;
	}

	// access to final variable not synchronized
	public File getOutfile() {
		return outfile;
	}
	
	public synchronized void setFinishTime(long time) {
		finishTimeInNanos = time;
	}
	
	public synchronized long getElapsedTime() {
		return finishTimeInNanos - startTimeInNanos;
	}
	
	public synchronized int getUploaded() {
		return uploaded;
	}

	public synchronized void setUploaded(int uploaded) {
		this.uploaded = uploaded;
	}

	public synchronized int getLeft() {
		return left;
	}

	public synchronized String getEvent() {
		return event;
	}

	public synchronized void setEvent(String event) {
		this.event = event;
	}

	public synchronized int getDownloaded() {
		return downloaded;
	}
	
	/* 
	 * Updates the amount downloaded, for a received payload (i.e. piece).
	 * @param downloadChange the number of bytes received AND verified
	 */
	public synchronized void updateDownloadStats(int downloadChange) {
		downloaded += downloadChange;
		left -= downloadChange;
	}
	
	public synchronized void updateUploadStats(int uploadChange) {
		uploaded += uploadChange;
	}
	
	public synchronized int getListeningPort() {
		return listeningPort;
	}
	
	public synchronized void setListeningPort(int port) {
		listeningPort = port;
	}
	
}
